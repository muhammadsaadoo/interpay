# API Gateway Tools Testing Guide 🧪

Let me show you how to test each feature with practical examples and monitoring.

## 1. Rate Limiter Testing

### Test Configuration:
```yaml
# Use this in your config for testing
- name: RequestRateLimiter
  args:
    redis-rate-limiter:
      replenishRate: 2    # 🎯 2 requests per second
      burstCapacity: 3    # 💥 Max 3 quick requests
      requestedTokens: 1
    key-resolver: "#{@userKeyResolver}"
```

### Test Commands:
```bash
# Test 1: Rapid requests to trigger rate limit
echo "🚀 Testing Rate Limiter - 5 requests in 2 seconds"
for i in {1..5}; do
  curl -X POST http://localhost:8086/auth/signup \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"user$i\",\"password\":\"pass$i\"}" \
    -w " | Status: %{http_code}\n"
  sleep 0.3
done

# Test 2: Different users (IPs) should have separate limits
echo "🧪 Testing different users (IP simulation)"
curl -X POST http://localhost:8086/auth/login \
  -H "Content-Type: application/json" \
  -H "X-Forwarded-For: 192.168.1.100" \
  -d '{"username":"test1","password":"pass1"}'

curl -X POST http://localhost:8086/auth/login \
  -H "Content-Type: application/json" \
  -H "X-Forwarded-For: 192.168.1.101" \
  -d '{"username":"test2","password":"pass2"}'

# Both should work - different IPs = different rate limits
```

### Monitor Rate Limiting:
```bash
# Check Redis keys for rate limiting
redis-cli keys "*rate*"
redis-cli get "request_rate_limiter.{ip_127.0.0.1}.tokens"
redis-cli get "request_rate_limiter.{ip_127.0.0.1}.timestamp"
```

## 2. Circuit Breaker Testing

### Create a Test Endpoint in User Service:
```java
// Add this to your User Service for testing
@RestController
public class TestController {

    private static boolean shouldFail = false;

    // Endpoint that can be made to fail
    @GetMapping("/api/test/circuit")
    public String testCircuitBreaker() {
        if (shouldFail) {
            throw new RuntimeException("Simulated service failure");
        }
        return "Service is working normally";
    }

    // Endpoint to toggle failure mode
    @PostMapping("/api/test/toggle-failure")
    public String toggleFailure() {
        shouldFail = !shouldFail;
        return "Failure mode: " + shouldFail;
    }

    // Slow endpoint for timeout testing
    @GetMapping("/api/test/slow")
    public String slowEndpoint() throws InterruptedException {
        Thread.sleep(3000); // 3 second delay
        return "Slow response completed";
    }
}
```

### Test Circuit Breaker:
```bash
# Test 1: Normal operation
echo "✅ Testing normal requests"
for i in {1..3}; do
  curl http://localhost:8086/api/test/circuit
  echo ""
done

# Test 2: Enable failures in user service
echo "🔴 Activating failure mode"
curl -X POST http://localhost:8085/api/test/toggle-failure

# Test 3: Make failing requests to open circuit
echo "💥 Making failing requests..."
for i in {1..6}; do
  curl http://localhost:8086/api/test/circuit
  echo " | Request $i"
  sleep 0.5
done

# Test 4: Circuit should be OPEN now - requests go to fallback
echo "🛟 Circuit should be OPEN - testing fallback"
curl http://localhost:8086/api/test/circuit

# Test 5: Wait and test half-open state
echo "⏰ Waiting for circuit to go HALF_OPEN..."
sleep 10
curl http://localhost:8086/api/test/circuit

# Test 6: Disable failures and verify recovery
echo "✅ Disabling failure mode"
curl -X POST http://localhost:8085/api/test/toggle-failure
curl http://localhost:8086/api/test/circuit
```

### Monitor Circuit Breaker:
```bash
# Check circuit breaker state
curl http://localhost:8086/actuator/health
curl http://localhost:8086/actuator/circuitbreakers

# Check metrics
curl http://localhost:8086/actuator/metrics/resilience4j.circuitbreaker.calls
```

## 3. Retry Mechanism Testing

### Test Configuration:
```yaml
# Enhanced retry config for testing
- name: Retry
  args:
    retries: 3
    series: SERVER_ERROR
    methods: GET,POST
    exceptions:
      - java.io.IOException
      - java.util.concurrent.TimeoutException
    backoff:
      firstBackoff: 1000ms  # ⏰ 1 second - visible delay
      maxBackoff: 5000ms
      factor: 2
```

### Test Retry with Flaky Endpoint:
```java
// Add to User Service TestController
private static int callCount = 0;

@GetMapping("/api/test/flaky")
public String flakyEndpoint() {
    callCount++;
    System.out.println("📞 Flaky endpoint call #" + callCount);

    if (callCount % 3 != 0) { // Fail first two calls, succeed on third
        throw new RuntimeException("Flaky service failure - call " + callCount);
    }

    callCount = 0; // Reset for next test
    return "Success after retries!";
}

@GetMapping("/api/test/reset")
public String resetCounter() {
    callCount = 0;
    return "Counter reset";
}
```

### Test Retry:
```bash
# Test 1: Retry with flaky endpoint
echo "🔄 Testing retry mechanism"
curl http://localhost:8086/api/test/flaky

# You should see in user service logs:
# Call #1 - Failure
# Call #2 - Failure
# Call #3 - Success (after retries)

# Test 2: Check logs to see retry delays
echo "⏱️ Testing with visible delays"
curl http://localhost:8086/api/test/flaky

# Reset for next test
curl http://localhost:8085/api/test/reset
```

## 4. Load Balancer Testing

### Start Multiple User Service Instances:
```bash
# Start user service on different ports
java -jar user-service.jar --server.port=8081 --spring.application.name=user-service &
java -jar user-service.jar --server.port=8082 --spring.application.name=user-service &
java -jar user-service.jar --server.port=8083 --spring.application.name=user-service &
```

### Test Load Balancing:
```bash
# Add instance identifier to user service
# In User Service controller:
@Value("${server.port}")
private String port;

@GetMapping("/api/test/instance")
public String getInstanceInfo() {
    return "Response from instance: " + port;
}

# Test load balancing
echo "⚖️ Testing Load Balancing - Round Robin"
for i in {1..9}; do
  curl http://localhost:8086/api/test/instance
  echo ""
  sleep 0.5
done

# Should see responses from different ports in round-robin fashion
```

## 5. Complete End-to-End Test

### Create Test Script:
```bash
#!/bin/bash
# gateway-test.sh

echo "🚀 STARTING API GATEWAY COMPREHENSIVE TEST"
echo "==========================================="

# 1. Test Rate Limiter
echo ""
echo "1. 🔄 TESTING RATE LIMITER"
echo "--------------------------"
for i in {1..5}; do
  response=$(curl -s -w "HTTP %{http_code}" -o /dev/null \
    -X POST http://localhost:8086/auth/signup \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"loadtest$i\",\"password\":\"pass\"}")
  echo "Request $i: $response"
  sleep 0.2
done

# 2. Test Circuit Breaker
echo ""
echo "2. 🔌 TESTING CIRCUIT BREAKER"
echo "-----------------------------"
echo "Making service fail..."
curl -X POST http://localhost:8085/api/test/toggle-failure > /dev/null 2>&1

for i in {1..4}; do
  response=$(curl -s http://localhost:8086/api/test/circuit)
  echo "Request $i: $response"
done

echo "Circuit should be OPEN now"
fallback_response=$(curl -s http://localhost:8086/api/test/circuit)
echo "Fallback response: $fallback_response"

# 3. Test Retry
echo ""
echo "3. 🔄 TESTING RETRY MECHANISM"
echo "-----------------------------"
curl http://localhost:8085/api/test/reset > /dev/null 2>&1
retry_response=$(curl -s http://localhost:8086/api/test/flaky)
echo "Retry result: $retry_response"

# 4. Restore normal operation
echo ""
echo "4. ✅ RESTORING NORMAL OPERATION"
echo "-------------------------------"
curl -X POST http://localhost:8085/api/test/toggle-failure > /dev/null 2>&1
curl http://localhost:8085/api/test/reset > /dev/null 2>&1

echo "✅ All tests completed!"
```

## 6. Real-Time Monitoring Setup

### Enhanced Logging Configuration:
```yaml
logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    org.springframework.cloud.gateway.filter: TRACE
    org.springframework.cloud.gateway.handler: TRACE
    reactor.netty: DEBUG
    io.github.resilience4j: DEBUG
```

### Monitor in Real-Time:
```bash
# Terminal 1: Watch gateway logs
tail -f logs/application.log | grep -E "(Route matched|CircuitBreaker|RateLimiter|Retry)"

# Terminal 2: Watch Redis
redis-cli monitor | grep -E "rate_limiter"

# Terminal 3: Watch user service logs
tail -f user-service.log

# Terminal 4: Run tests
./gateway-test.sh
```

## 7. Visualization with Actuator Endpoints

### Check All Metrics:
```bash
# Gateway routes
curl http://localhost:8086/actuator/gateway/routes | jq .

# Circuit breaker states
curl http://localhost:8086/actuator/circuitbreakers | jq .

# Health with details
curl http://localhost:8086/actuator/health | jq .

# Metrics for rate limiting
curl http://localhost:8086/actuator/metrics/gateway.requests | jq .

# Resilience4j metrics
curl http://localhost:8086/actuator/metrics/resilience4j.circuitbreaker.calls | jq .
```

## 8. Expected Test Results

### Rate Limiter:
```
✅ Request 1: HTTP 200
✅ Request 2: HTTP 200
✅ Request 3: HTTP 200 (burst)
🚫 Request 4: HTTP 429 Too Many Requests
🚫 Request 5: HTTP 429 Too Many Requests
```

### Circuit Breaker:
```
✅ Request 1-2: Normal responses
🔴 Request 3-5: Service failures
🛟 Request 6: Fallback response (circuit OPEN)
⏰ Wait 10 seconds...
🟡 Request 7: Test call (HALF_OPEN)
✅ Request 8: Normal response (circuit CLOSED)
```

### Retry Mechanism:
```
📞 User Service Logs:
Call #1: Failed
Call #2: Failed
Call #3: Success! (after 2 retries)
```

This testing approach will give you complete visibility into how each gateway feature works! 🎯
rate limiter works correct

